<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hone Playground</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --bg: #1e1e2e;
      --bg-surface: #181825;
      --bg-overlay: #313244;
      --text: #cdd6f4;
      --text-dim: #a6adc8;
      --border: #45475a;
      --accent: #89b4fa;
      --error: #f38ba8;
      --success: #a6e3a1;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 16px;
      background: var(--bg-surface);
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
    }

    header h1 {
      font-size: 18px;
      font-weight: 600;
    }

    header h1 span {
      color: var(--accent);
    }

    .toolbar {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    select, button {
      background: var(--bg-overlay);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 4px 10px;
      font-size: 13px;
      cursor: pointer;
    }

    select:hover, button:hover {
      border-color: var(--accent);
    }

    button.share {
      background: var(--accent);
      color: var(--bg);
      border: none;
      font-weight: 500;
    }

    button.format-btn {
      background: transparent;
      border: 1px solid var(--border);
    }

    button.format-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    .toggle-label {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 13px;
      color: var(--text-dim);
      cursor: pointer;
    }

    .toggle-label input[type="checkbox"] {
      accent-color: var(--accent);
      cursor: pointer;
    }

    .options-bar {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 4px 16px;
      background: var(--bg-surface);
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
      font-size: 12px;
    }

    .options-bar label {
      color: var(--text-dim);
    }

    .options-bar input {
      background: var(--bg-overlay);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 3px;
      padding: 2px 6px;
      font-size: 12px;
      font-family: "JetBrains Mono", "Fira Code", monospace;
      outline: none;
    }

    .options-bar input:focus {
      border-color: var(--accent);
    }

    .options-bar input::placeholder {
      color: var(--border);
    }

    .main {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    .pane {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .pane:first-child {
      border-right: 1px solid var(--border);
    }

    .pane-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 6px 12px;
      background: var(--bg-surface);
      border-bottom: 1px solid var(--border);
      font-size: 12px;
      color: var(--text-dim);
      flex-shrink: 0;
    }

    .tabs {
      display: flex;
      gap: 2px;
    }

    .tab {
      padding: 3px 10px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 12px;
      color: var(--text-dim);
    }

    .tab.active {
      background: var(--bg-overlay);
      color: var(--text);
    }

    .tab:hover:not(.active) {
      color: var(--text);
    }

    .file-tabs {
      display: flex;
      gap: 2px;
      padding: 0 12px;
      background: var(--bg-surface);
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
    }

    .file-tab {
      padding: 4px 12px;
      font-size: 12px;
      font-family: "JetBrains Mono", "Fira Code", monospace;
      color: var(--text-dim);
      cursor: pointer;
      border-bottom: 2px solid transparent;
      margin-bottom: -1px;
    }

    .file-tab.active {
      color: var(--accent);
      border-bottom-color: var(--accent);
    }

    .file-tab:hover:not(.active) {
      color: var(--text);
    }

    #editor-container {
      flex: 1;
      overflow: hidden;
    }

    #output {
      flex: 1;
      background: var(--bg);
      color: var(--text);
      padding: 12px;
      font-family: "JetBrains Mono", "Fira Code", "Cascadia Code", "Consolas", monospace;
      font-size: 14px;
      line-height: 1.5;
      overflow: auto;
      white-space: pre;
    }

    #output.error {
      color: var(--error);
    }

    .status {
      font-size: 11px;
    }

    .status.ok { color: var(--success); }
    .status.err { color: var(--error); }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs/loader.min.js"></script>
</head>
<body>
  <header>
    <h1><span>Hone</span> Playground</h1>
    <div class="toolbar">
      <select id="examples">
        <option value="">-- Examples --</option>
        <option value="basics">Basics</option>
        <option value="kubernetes">Kubernetes Config</option>
        <option value="schema">Schema Validation</option>
        <option value="variant">Variants</option>
        <option value="interpolation">String Interpolation</option>
        <option value="args">CLI Args (expect)</option>
        <option value="dynamic_keys">Dynamic Keys & Dicts</option>
        <option value="functions">Functions (fn)</option>
        <option value="builtins">Built-in Functions</option>
        <option value="mandelbrot">Mandelbrot Set</option>
        <option value="k8s_schemas">K8s Schemas (multi-file)</option>
        <option value="microservices">Microservices (multi-file)</option>
        <option value="ci_pipeline">CI Pipeline (multi-file)</option>
        <option value="ansible">Ansible Playbook (multi-file)</option>
      </select>
      <select id="format">
        <option value="yaml">YAML</option>
        <option value="json">JSON</option>
        <option value="toml">TOML</option>
        <option value="dotenv">.env</option>
      </select>
      <label class="toggle-label" id="prettyToggle" style="display: none;">
        <input type="checkbox" id="prettyPrint" checked> Pretty
      </label>
      <button class="format-btn" onclick="formatCode()">Format</button>
      <button class="share" onclick="share()">Share</button>
    </div>
  </header>
  <div class="options-bar" id="optionsBar" style="display: none;">
    <label>Variants:</label>
    <input type="text" id="variantInput" placeholder='env=production' size="20">
    <label>Args:</label>
    <input type="text" id="argsInput" placeholder='port=8080 env=prod' size="25">
  </div>
  <div class="main">
    <div class="pane">
      <div class="pane-header">
        <span>Source</span>
        <span class="status" id="status"></span>
      </div>
      <div class="file-tabs" id="fileTabs" style="display: none;"></div>
      <div id="editor-container"></div>
    </div>
    <div class="pane">
      <div class="pane-header">
        <div class="tabs">
          <div class="tab active" data-format="yaml" onclick="setFormat('yaml')">YAML</div>
          <div class="tab" data-format="json" onclick="setFormat('json')">JSON</div>
          <div class="tab" data-format="toml" onclick="setFormat('toml')">TOML</div>
          <div class="tab" data-format="dotenv" onclick="setFormat('dotenv')">.env</div>
        </div>
      </div>
      <div class="file-tabs" id="outputTabs" style="display: none;"></div>
      <div id="output"></div>
    </div>
  </div>

  <script type="module">
    import init, { compile, compile_project, format_source, get_diagnostics, get_completions, get_hover } from './pkg/hone_wasm.js';

    let wasm;
    let editor; // Monaco editor instance
    let monaco; // Monaco namespace
    const outputEl = document.getElementById('output');
    const statusEl = document.getElementById('status');
    const formatSelect = document.getElementById('format');
    const examplesSelect = document.getElementById('examples');
    const variantInput = document.getElementById('variantInput');
    const argsInput = document.getElementById('argsInput');
    const optionsBar = document.getElementById('optionsBar');
    const prettyPrint = document.getElementById('prettyPrint');
    const prettyToggle = document.getElementById('prettyToggle');
    const fileTabsEl = document.getElementById('fileTabs');
    const outputTabsEl = document.getElementById('outputTabs');
    let currentFormat = 'yaml';
    let debounceTimer;
    let diagnosticsTimer;

    // Multi-file state
    let projectFiles = {};     // { filename: source }
    let activeFile = null;     // current tab filename
    let isMultiFile = false;

    // Multi-doc output state
    let outputDocs = [];       // [{name, content}]
    let activeOutputDoc = 0;   // index into outputDocs

    const EXAMPLES = {
      basics: `# Hone Basics
let env = "production"
let base_port = 8000

app {
  name: "api-\${env}"
  port: base_port + 80
  debug: env != "production"
  tags: ["web", "api", env]
}

# Loops
let services = for name in ["auth", "users", "billing"] {
  "\${name}-svc": {
    url: "http://\${name}.\${env}.internal"
    port: base_port + 1
  }
}

services: services`,
      kubernetes: `# Kubernetes Deployment
let app = "my-app"
let env = "production"
let replicas = env == "production" ? 3 : 1

apiVersion: "apps/v1"
kind: "Deployment"
metadata {
  name: "\${app}-\${env}"
  labels {
    app: app
    env: env
  }
}
spec {
  replicas: replicas
  selector {
    matchLabels {
      app: app
    }
  }
  template {
    metadata {
      labels {
        app: app
        env: env
      }
    }
    spec {
      containers: [{
        name: app
        image: "registry.example.com/\${app}:latest"
        ports: [{ containerPort: 8080 }]
        resources {
          limits: { cpu: "500m", memory: "256Mi" }
          requests: { cpu: "100m", memory: "128Mi" }
        }
      }]
    }
  }
}`,
      schema: `# Schema Validation
schema Server {
  host: string
  port: int(1, 65535)
  name: string(1, 100)
  debug?: bool
}

use Server

host: "api.example.com"
port: 8080
name: "production-api"
debug: false`,
      variant: `# Variant System
# Try setting Variants to: env=production
variant env {
  default dev {
    replicas: 1
    debug: true
    log_level: "debug"
    resources {
      cpu: "100m"
      memory: "128Mi"
    }
  }

  staging {
    replicas: 2
    debug: false
    log_level: "info"
    resources {
      cpu: "250m"
      memory: "256Mi"
    }
  }

  production {
    replicas: 5
    debug: false
    log_level: "warn"
    resources {
      cpu: "1000m"
      memory: "1Gi"
    }
  }
}

name: "api-server"
version: "2.1.0"`,
      interpolation: `# String Interpolation
let greeting = "Hello"
let name = "World"

# Basic interpolation
message: "\${greeting}, \${name}!"

# Expressions in interpolation
math: "2 + 2 = \${2 + 2}"

# Nested access
let config = { host: "localhost", port: 8080 }
url: "http://\${config.host}:\${config.port}"

# Built-in functions
encoded: base64_encode("secret-token")
upper_name: upper(name)
parts: split("a,b,c", ",")
joined: join(["x", "y", "z"], "-")`,
      args: `# CLI Args with expect
# Try setting Args to: env=prod port=9090
expect args.env: string = "dev"
expect args.port: int = 8080
expect args.debug: bool = false

host: "api-\${args.env}.example.com"
port: args.port
debug: args.debug`,
      mandelbrot: `# Mandelbrot Set \u2014 ASCII art computed entirely in Hone
#
# This is a configuration language. We are rendering a fractal.
# Each pixel is computed independently using manually-unrolled
# iterations of z = z^2 + c with complex arithmetic.
#
# Run:
#   hone compile examples/mandelbrot.hone --format yaml
#   hone compile examples/mandelbrot.hone --format json

let width = 72
let height = 28
let x_min = -2.2
let x_max = 0.8
let y_min = -1.2
let y_max = 1.2

let x_step = (x_max - x_min) / width
let y_step = (y_max - y_min) / height

# 8 iterations of z = z^2 + c per pixel, ~2000 complex multiplications.

art: for py in range(0, height) {
  let cy = y_max - py * y_step
  let row = for px in range(0, width) {
    let cx = x_min + px * x_step

    let z1r = cx
    let z1i = cy
    let z2r = z1r * z1r - z1i * z1i + cx
    let z2i = 2.0 * z1r * z1i + cy
    let z3r = z2r * z2r - z2i * z2i + cx
    let z3i = 2.0 * z2r * z2i + cy
    let z4r = z3r * z3r - z3i * z3i + cx
    let z4i = 2.0 * z3r * z3i + cy
    let z5r = z4r * z4r - z4i * z4i + cx
    let z5i = 2.0 * z4r * z4i + cy
    let z6r = z5r * z5r - z5i * z5i + cx
    let z6i = 2.0 * z5r * z5i + cy
    let z7r = z6r * z6r - z6i * z6i + cx
    let z7i = 2.0 * z6r * z6i + cy
    let z8r = z7r * z7r - z7i * z7i + cx
    let z8i = 2.0 * z7r * z7i + cy

    let m1 = z1r * z1r + z1i * z1i
    let m2 = z2r * z2r + z2i * z2i
    let m3 = z3r * z3r + z3i * z3i
    let m4 = z4r * z4r + z4i * z4i
    let m5 = z5r * z5r + z5i * z5i
    let m6 = z6r * z6r + z6i * z6i
    let m7 = z7r * z7r + z7i * z7i
    let m8 = z8r * z8r + z8i * z8i

    m1 > 4.0 ? " " : m2 > 4.0 ? "." : m3 > 4.0 ? ":" : m4 > 4.0 ? "-" : m5 > 4.0 ? "=" : m6 > 4.0 ? "+" : m7 > 4.0 ? "*" : m8 > 4.0 ? "#" : "@"
  }
  join(row, "")
}`,
      dynamic_keys: `# Dynamic Keys & Dicts
# Hone has three ways to create dynamic object keys

let env = "prod"
let envs = ["dev", "staging", "prod"]

# ─── 1. Interpolated String Keys ──────────────────────────────
# Wrap a key in quotes with \${} to compute it from variables.

"\${env}-host": "api.\${env}.example.com"
"\${env}-port": 8080

# Works great in loops too:
services: for name in ["auth", "users", "billing"] {
  "\${name}-url": "https://\${name}.\${env}.internal"
}

# ─── 2. Computed Keys [expr] ─────────────────────────────────
# Use [expr] for keys that are arbitrary expressions.

let key_name = "dynamic"
[key_name]: 42
[upper(key_name)]: "uppercase key"
["item-" + to_str(len(envs))]: "computed from expression"

# ─── 3. Dict via For-in-Body ─────────────────────────────────
# A for loop IN A BLOCK merges iterations into a flat object.
# This is how you build a dict/map dynamically.

endpoints {
  for e in envs {
    "\${e}": "https://\${e}.example.com"
  }
}
# Result: { dev: "https://...", staging: "https://...", prod: "https://..." }

# ─── For-as-Expression = Array ────────────────────────────────
# A for loop AS AN EXPRESSION produces an array of objects.

let endpoint_list = for e in envs {
  "\${e}": "https://\${e}.example.com"
}
endpoint_list: endpoint_list
# Result: [ {dev: "https://..."}, {staging: "https://..."}, {prod: "https://..."} ]`,
      functions: `# User-Defined Functions
# Define reusable logic with fn. Functions are defined in the
# preamble (top of file) and return a single expression.

# --- All fn definitions go in the preamble ---

# Basic functions
fn double(x) { x * 2 }
fn greet(name, title) { "Hello, \${title} \${name}!" }
fn is_production(env) { env == "production" || env == "prod" }

# Functions that call builtins
fn slugify(text) { lower(replace(trim(text), " ", "-")) }
fn shout(text) { upper(text) + "!" }
fn csv_to_list(csv_string) { split(trim(csv_string), ",") }

# Functions that call other functions
fn make_label(app, env) { "\${slugify(app)}-\${env}" }
fn make_fqdn(app, env, domain) { "\${slugify(app)}.\${env}.\${domain}" }

# Functions that return objects
fn service_url(name, port) { "http://\${name}.internal:\${to_str(port)}" }
fn resource_spec(cpu_m, mem_mb) {
  { cpu: "\${to_str(cpu_m)}m", memory: "\${to_str(mem_mb)}Mi" }
}

# Functions with conditionals
fn tier(replicas) {
  replicas >= 5 ? "production" : replicas >= 2 ? "staging" : "development"
}
fn clamp_replicas(n, env) {
  is_production(env) ? max(n, 3) : min(n, 2)
}

# Kubernetes helpers
fn k8s_labels(app, component, version) {
  {
    "app.kubernetes.io/name": slugify(app),
    "app.kubernetes.io/component": component,
    "app.kubernetes.io/version": version,
    "app.kubernetes.io/managed-by": "hone"
  }
}
fn k8s_selector(app) { { "app.kubernetes.io/name": slugify(app) } }

let service_names = ["auth", "users", "billing", "notifications"]

# --- Body: use the functions ---

basics {
  doubled: double(21)
  message: greet("Alice", "Dr.")
  check: is_production("prod")
}

string_helpers {
  slug: slugify("  My Cool App  ")
  loud: shout("hello world")
  parsed: csv_to_list("a,b,c,d")
}

composition {
  label: make_label("My Service", "prod")
  fqdn: make_fqdn("My Service", "staging", "example.com")
}

# Functions in loops
services: for (i, name) in service_names {
  "\${name}": {
    url: service_url(name, 8000 + i),
    resources: resource_spec((i + 1) * 100, (i + 1) * 128)
  }
}

scaling {
  tier_1: tier(1)
  tier_3: tier(3)
  tier_10: tier(10)
  prod_replicas: clamp_replicas(1, "production")
  dev_replicas: clamp_replicas(10, "dev")
}

# Real-world: Kubernetes label generator
deployment {
  metadata {
    labels: k8s_labels("My App", "api", "2.1.0")
  }
  spec {
    selector {
      matchLabels: k8s_selector("My App")
    }
  }
}`,
      builtins: `# Built-in Functions Showcase
# Hone ships with 40 built-in functions for strings, arrays,
# objects, math, encoding, and type conversion.

# All variables go in the preamble
let numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]
let config = { host: "localhost", port: 8080, debug: true }
let upper_pairs = for (key, val) in config { [upper(key), val] }
let maybe_null = null
let has_value = "present"
let environments = ["dev", "staging", "production"]
let base_port = 8000
let raw_tags = ["web", "api", "web", "backend", "api", "frontend"]
let port_entries = for (i, env) in environments { [env, { port: base_port + i, name: upper(env), id: substring(sha256(env), 0, 8) }] }

# --- String Functions ---

strings {
  upper: upper("hello")
  lower: lower("WORLD")
  trimmed: trim("  padded  ")
  parts: split("a,b,c", ",")
  joined: join(["x", "y", "z"], "-")
  replaced: replace("foo-bar-baz", "-", "_")
  has_prefix: starts_with("hello world", "hello")
  has_suffix: ends_with("config.yaml", ".yaml")
  sub: substring("abcdefgh", 2, 5)
  length: len("unicode")
}

# --- Array Functions ---

arrays {
  sorted: sort(numbers)
  reversed: reverse(numbers)
  no_dupes: unique(numbers)
  first_three: slice(numbers, 0, 3)
  last_three: slice(numbers, -3)
  combined: concat([1, 2], [3, 4], [5])
  flattened: flatten([[1, 2], [3, [4, 5]]])
  has_five: contains(numbers, 5)
  count: len(numbers)
}

# --- Object Functions ---

objects {
  all_keys: keys(config)
  all_values: values(config)
  merged: merge(config, { port: 9090, tls: true })
  pairs: entries(config)
  roundtrip: from_entries(entries(config))
  uppercased: from_entries(upper_pairs)
}

# --- Math Functions ---

math {
  minimum: min(42, 17)
  maximum: max(42, 17)
  absolute: abs(-99)
  clamped_low: clamp(-5, 0, 100)
  clamped_high: clamp(999, 0, 100)
  clamped_ok: clamp(50, 0, 100)
  integers: range(1, 6)
}

# --- Type Functions ---

types {
  int_type: type_of(42)
  float_type: type_of(3.14)
  string_type: type_of("hi")
  bool_type: type_of(true)
  null_type: type_of(null)
  array_type: type_of([1, 2])
  object_type: type_of({a: 1})
}

# --- Conversion Functions ---

conversions {
  to_string: to_str(42)
  to_integer: to_int("99")
  to_floating: to_float("3.14")
  to_boolean: to_bool(1)
  bool_false: to_bool(0)
  bool_empty: to_bool("")
}

# --- Encoding Functions ---

encoding {
  b64_encoded: base64_encode("Hello, World!")
  b64_decoded: base64_decode("SGVsbG8sIFdvcmxkIQ==")
  json_string: to_json({ nested: { value: [1, 2, 3] } })
  from_string: from_json("{\\"x\\": 42}")
  hashed: sha256("deterministic-input")
}

# --- Null Handling ---

null_handling {
  with_default: default(maybe_null, "fallback")
  not_needed: default(has_value, "fallback")
  coalesce: maybe_null ?? "also works"
}

# --- Composed: Real-World Patterns ---

# Generate a port mapping with unique hashes for identification
port_map: from_entries(port_entries)

# Filter-like pattern: unique sorted tags
clean_tags: sort(unique(raw_tags))`,
    };

    // Multi-file examples: { files: { name: source }, entry: name }
    const MULTI_EXAMPLES = {
      k8s_schemas: {
        entry: './main.hone',
        files: {
'./main.hone': `# Kubernetes Deployment with Schema Validation
#
# This example imports K8s schema definitions and validates
# a Deployment manifest at compile time. Try introducing errors:
#   - Change replicas to a string: replicas: "3"
#   - Remove containers from spec
#   - Set containerPort to a string
#
# The schema library is in lib/k8s/v1.30/ (78 schemas).
# This playground includes a subset for Deployments.

import "./schemas.hone" as schemas

use Deployment

let app_name = "my-api"
let image_tag = "v1.2.0"

apiVersion: "apps/v1"
kind: "Deployment"
metadata {
  name: app_name
  namespace: "default"
  labels {
    "app.kubernetes.io/name": app_name
    "app.kubernetes.io/version": image_tag
  }
}
spec {
  replicas: 3
  selector {
    matchLabels {
      "app.kubernetes.io/name": app_name
    }
  }
  template {
    metadata {
      labels {
        "app.kubernetes.io/name": app_name
      }
    }
    spec {
      containers: [{
        name: app_name
        image: "ghcr.io/myorg/\${app_name}:\${image_tag}"
        ports: [{ containerPort: 8080, protocol: "TCP" }]
        env: [
          { name: "LOG_LEVEL", value: "info" }
          { name: "PORT", value: "8080" }
        ]
        resources {
          requests: { cpu: "100m", memory: "128Mi" }
          limits: { cpu: "500m", memory: "512Mi" }
        }
        readinessProbe {
          httpGet: { path: "/healthz", port: 8080 }
          initialDelaySeconds: 5
          periodSeconds: 10
        }
      }]
    }
  }
}`,
'./schemas.hone': `# K8s Schema Library (subset for Deployment validation)
#
# Auto-generated from kubernetes-json-schema v1.30.
# Full library: lib/k8s/v1.30/ (78 schemas across 7 files)

schema ObjectMeta {
  annotations?: object
  labels?: object
  name?: string
  namespace?: string
  ...
}

schema LabelSelector {
  matchExpressions?: array
  matchLabels?: object
  ...
}

schema Deployment {
  apiVersion?: string
  kind?: string
  metadata?: ObjectMeta
  spec?: DeploymentSpec
  status?: object
  ...
}

schema DeploymentSpec {
  minReadySeconds?: int
  paused?: bool
  replicas?: int
  revisionHistoryLimit?: int
  selector: LabelSelector
  template: PodTemplateSpec
  ...
}

schema PodTemplateSpec {
  metadata?: ObjectMeta
  spec?: PodSpec
  ...
}

schema PodSpec {
  containers: array
  initContainers?: array
  nodeName?: string
  restartPolicy?: string
  serviceAccountName?: string
  volumes?: array
  ...
}

schema Container {
  args?: array
  command?: array
  env?: array
  image?: string
  imagePullPolicy?: string
  livenessProbe?: Probe
  name: string
  ports?: array
  readinessProbe?: Probe
  resources?: ResourceRequirements
  volumeMounts?: array
  workingDir?: string
  ...
}

schema ContainerPort {
  containerPort: int
  hostPort?: int
  name?: string
  protocol?: string
  ...
}

schema EnvVar {
  name: string
  value?: string
  valueFrom?: object
  ...
}

schema Probe {
  exec?: object
  failureThreshold?: int
  httpGet?: HTTPGetAction
  initialDelaySeconds?: int
  periodSeconds?: int
  successThreshold?: int
  tcpSocket?: object
  timeoutSeconds?: int
  ...
}

schema HTTPGetAction {
  host?: string
  path?: string
  port: int
  scheme?: string
  ...
}

schema ResourceRequirements {
  limits?: object
  requests?: object
  ...
}`,
        },
      },
      microservices: {
        entry: './main.hone',
        files: {
'./main.hone': `# Microservices Stack \u2014 Kubernetes Manifests
#
# A complete multi-service deployment: API server, background worker,
# Redis cache, and Postgres database.

import "./config.hone" as config
import "./resources.hone" as res
import "./schemas.hone" as schemas

# Validate the final output
use Stack

# Accept an image tag override from the CLI
expect args.image_tag: string = config.version

# Environment variants
variant env {
  default dev {
    let api_replicas = 1
    let worker_replicas = 1
    let log_level = "debug"
    let redis_storage = "1Gi"
    let pg_storage = "5Gi"
    let pg_replicas = 1
  }
  staging {
    let api_replicas = 2
    let worker_replicas = 2
    let log_level = "info"
    let redis_storage = "5Gi"
    let pg_storage = "20Gi"
    let pg_replicas = 1
  }
  production {
    let api_replicas = 5
    let worker_replicas = 3
    let log_level = "warn"
    let redis_storage = "10Gi"
    let pg_storage = "100Gi"
    let pg_replicas = 3
  }
}

# Shared labels applied to every resource
let common_labels = {
  "app.kubernetes.io/part-of": config.app_name,
  "app.kubernetes.io/version": args.image_tag,
  "app.kubernetes.io/managed-by": "hone",
}

# Helper: build a container spec
let make_container = {
  name: config.app_name,
  image: "\${config.registry}/\${config.app_name}:\${args.image_tag}",
  imagePullPolicy: "IfNotPresent",
}

# \u2500\u2500\u2500 API Server \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500

---api-deployment
apiVersion: "apps/v1"
kind: "Deployment"
metadata {
  name: "\${config.app_name}-api"
  namespace: config.namespace
  labels {
    ...common_labels
    "app.kubernetes.io/component": "api"
  }
}
spec {
  replicas: api_replicas
  selector {
    matchLabels {
      "app.kubernetes.io/name": "\${config.app_name}-api"
    }
  }
  template {
    metadata {
      labels {
        ...common_labels
        "app.kubernetes.io/name": "\${config.app_name}-api"
        "app.kubernetes.io/component": "api"
      }
    }
    spec {
      containers: [{
        ...make_container,
        name: "api",
        command: ["./server", "--mode", "api"],
        ports: [{ containerPort: config.api_port, protocol: "TCP" }],
        env: [
          { name: "LOG_LEVEL", value: log_level },
          { name: "PORT", value: to_str(config.api_port) },
          { name: "REDIS_URL", value: "redis://\${config.app_name}-redis:6379" },
          { name: "DATABASE_URL", valueFrom: { secretKeyRef: { name: "\${config.app_name}-secrets", key: "database-url" } } },
        ],
        resources: res.api,
        readinessProbe: {
          httpGet: { path: "/healthz", port: config.api_port },
          initialDelaySeconds: 5,
          periodSeconds: 10,
        },
        livenessProbe: {
          httpGet: { path: "/healthz", port: config.api_port },
          initialDelaySeconds: 15,
          periodSeconds: 20,
        },
      }]
    }
  }
}

---api-service
apiVersion: "v1"
kind: "Service"
metadata {
  name: "\${config.app_name}-api"
  namespace: config.namespace
  labels {
    ...common_labels
    "app.kubernetes.io/component": "api"
  }
}
spec {
  selector {
    "app.kubernetes.io/name": "\${config.app_name}-api"
  }
  ports: [{
    name: "http",
    port: 80,
    targetPort: config.api_port,
    protocol: "TCP",
  }]
}

# \u2500\u2500\u2500 Background Worker \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500

---worker-deployment
apiVersion: "apps/v1"
kind: "Deployment"
metadata {
  name: "\${config.app_name}-worker"
  namespace: config.namespace
  labels {
    ...common_labels
    "app.kubernetes.io/component": "worker"
  }
}
spec {
  replicas: worker_replicas
  selector {
    matchLabels {
      "app.kubernetes.io/name": "\${config.app_name}-worker"
    }
  }
  template {
    metadata {
      labels {
        ...common_labels
        "app.kubernetes.io/name": "\${config.app_name}-worker"
        "app.kubernetes.io/component": "worker"
      }
    }
    spec {
      containers: [{
        ...make_container,
        name: "worker",
        command: ["./server", "--mode", "worker"],
        env: [
          { name: "LOG_LEVEL", value: log_level },
          { name: "REDIS_URL", value: "redis://\${config.app_name}-redis:6379" },
          { name: "DATABASE_URL", valueFrom: { secretKeyRef: { name: "\${config.app_name}-secrets", key: "database-url" } } },
        ],
        resources: res.worker,
      }]
    }
  }
}

# \u2500\u2500\u2500 Redis \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500

---redis
apiVersion: "apps/v1"
kind: "StatefulSet"
metadata {
  name: "\${config.app_name}-redis"
  namespace: config.namespace
  labels {
    ...common_labels
    "app.kubernetes.io/component": "cache"
  }
}
spec {
  serviceName: "\${config.app_name}-redis"
  replicas: 1
  selector {
    matchLabels {
      "app.kubernetes.io/name": "\${config.app_name}-redis"
    }
  }
  template {
    metadata {
      labels {
        ...common_labels
        "app.kubernetes.io/name": "\${config.app_name}-redis"
        "app.kubernetes.io/component": "cache"
      }
    }
    spec {
      containers: [{
        name: "redis",
        image: "redis:7-alpine",
        ports: [{ containerPort: 6379 }],
        resources: res.redis,
        volumeMounts: [{ name: "data", mountPath: "/data" }],
      }]
    }
  }
  volumeClaimTemplates: [{
    metadata: { name: "data" },
    spec: {
      accessModes: ["ReadWriteOnce"],
      resources: { requests: { storage: redis_storage } },
    },
  }]
}

---redis-service
apiVersion: "v1"
kind: "Service"
metadata {
  name: "\${config.app_name}-redis"
  namespace: config.namespace
}
spec {
  selector {
    "app.kubernetes.io/name": "\${config.app_name}-redis"
  }
  ports: [{ port: 6379, targetPort: 6379 }]
  clusterIP: "None"
}

# \u2500\u2500\u2500 Postgres \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500

---postgres
apiVersion: "apps/v1"
kind: "StatefulSet"
metadata {
  name: "\${config.app_name}-postgres"
  namespace: config.namespace
  labels {
    ...common_labels
    "app.kubernetes.io/component": "database"
  }
}
spec {
  serviceName: "\${config.app_name}-postgres"
  replicas: pg_replicas
  selector {
    matchLabels {
      "app.kubernetes.io/name": "\${config.app_name}-postgres"
    }
  }
  template {
    metadata {
      labels {
        ...common_labels
        "app.kubernetes.io/name": "\${config.app_name}-postgres"
        "app.kubernetes.io/component": "database"
      }
    }
    spec {
      containers: [{
        name: "postgres",
        image: "postgres:16-alpine",
        ports: [{ containerPort: 5432 }],
        env: [
          { name: "POSTGRES_DB", value: config.app_name },
          { name: "POSTGRES_USER", valueFrom: { secretKeyRef: { name: "\${config.app_name}-secrets", key: "pg-user" } } },
          { name: "POSTGRES_PASSWORD", valueFrom: { secretKeyRef: { name: "\${config.app_name}-secrets", key: "pg-password" } } },
        ],
        resources: res.postgres,
        volumeMounts: [{ name: "pgdata", mountPath: "/var/lib/postgresql/data" }],
      }]
    }
  }
  volumeClaimTemplates: [{
    metadata: { name: "pgdata" },
    spec: {
      accessModes: ["ReadWriteOnce"],
      resources: { requests: { storage: pg_storage } },
    },
  }]
}

---postgres-service
apiVersion: "v1"
kind: "Service"
metadata {
  name: "\${config.app_name}-postgres"
  namespace: config.namespace
}
spec {
  selector {
    "app.kubernetes.io/name": "\${config.app_name}-postgres"
  }
  ports: [{ port: 5432, targetPort: 5432 }]
  clusterIP: "None"
}`,
'./config.hone': `# Shared configuration values
type Port = int(1, 65535)
type Replicas = int(1, 50)
type SemVer = string("[0-9]+\\\\.[0-9]+\\\\.[0-9]+")
type K8sName = string(1, 63)
type StorageSize = string("[0-9]+[KMGT]i")

let app_name = "catapult"
let namespace = "catapult"
let version = "1.2.0"
let registry = "ghcr.io/catapult-platform"
let api_port = 8080`,
'./resources.hone': `# Resource limits and requests per component
let api = {
  requests: { cpu: "100m", memory: "256Mi" },
  limits: { cpu: "1000m", memory: "512Mi" },
}

let worker = {
  requests: { cpu: "200m", memory: "512Mi" },
  limits: { cpu: "2000m", memory: "1Gi" },
}

let redis = {
  requests: { cpu: "50m", memory: "64Mi" },
  limits: { cpu: "200m", memory: "256Mi" },
}

let postgres = {
  requests: { cpu: "100m", memory: "256Mi" },
  limits: { cpu: "1000m", memory: "1Gi" },
}`,
'./schemas.hone': `# Schema definitions for the microservices stack output
import "./config.hone" as config

schema ResourceSpec {
  cpu: string
  memory: string
}

schema Resources {
  requests: ResourceSpec
  limits: ResourceSpec
}

schema Container {
  name: K8sName
  image: string
  ...
}

schema Metadata {
  name: K8sName
  ...
}

# Top-level: validates the combined multi-document output
schema Stack {
  ...
}`,
        },
      },
      ci_pipeline: {
        entry: './main.hone',
        files: {
'./main.hone': `# CI/CD Pipeline \u2014 GitHub Actions Workflow
#
# A comprehensive workflow: lint, test matrix, build, Docker image, deploy.

import "./actions.hone" as actions

# \u2500\u2500 Matrix configuration \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500

let node_versions = ["18", "20", "22"]
let os_matrix = ["ubuntu-latest", "macos-latest"]

# Services that the test suite needs
let test_services = {
  postgres: {
    image: "postgres:16-alpine",
    env: {
      POSTGRES_USER: "test",
      POSTGRES_PASSWORD: "test",
      POSTGRES_DB: "test",
    },
    ports: ["5432:5432"],
    options: "--health-cmd pg_isready --health-interval 10s --health-timeout 5s --health-retries 5",
  },
  redis: {
    image: "redis:7-alpine",
    ports: ["6379:6379"],
    options: '--health-cmd "redis-cli ping" --health-interval 10s --health-timeout 5s --health-retries 5',
  },
}

# Environments reused for test and build steps
let test_env = {
  DATABASE_URL: "postgres://test:test@localhost:5432/test",
  REDIS_URL: "redis://localhost:6379",
  CI: "true",
}

# Deploy target (only with --variant deploy=production or deploy=staging)
variant deploy {
  default none {
    let deploy_enabled = false
    let deploy_env = "none"
    let deploy_url = ""
  }
  staging {
    let deploy_enabled = true
    let deploy_env = "staging"
    let deploy_url = "https://staging.example.com"
  }
  production {
    let deploy_enabled = true
    let deploy_env = "production"
    let deploy_url = "https://example.com"
  }
}

# \u2500\u2500 Workflow \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500

name: "CI/CD"

on {
  push {
    branches: ["main"]
  }
  pull_request {
    branches: ["main"]
  }
}

concurrency {
  group: '\${{ github.workflow }}-\${{ github.ref }}'
  "cancel-in-progress": true
}

jobs {
  lint {
    name: "Lint & Format"
    "runs-on": "ubuntu-latest"
    steps: [
      actions.checkout,
      actions.setup_node_fixed,
      actions.install_deps,
      { name: "Lint", run: "npm run lint" },
      { name: "Format check", run: "npm run format:check" },
      { name: "Type check", run: "npm run typecheck" },
    ]
  }

  test {
    name: "Test"
    "runs-on": '\${{ matrix.os }}'
    needs: ["lint"]
    strategy {
      "fail-fast": false
      matrix {
        "node-version": node_versions
        os: os_matrix
      }
    }
    services: test_services
    steps: [
      actions.checkout,
      actions.setup_node,
      actions.install_deps,
      {
        name: "Run tests",
        run: "npm test -- --coverage",
        env: test_env,
      },
      {
        name: "Upload coverage",
        "if": "matrix.node-version == '20' && matrix.os == 'ubuntu-latest'",
        uses: "codecov/codecov-action@v4",
        with: { token: '\${{ secrets.CODECOV_TOKEN }}' },
      },
    ]
  }

  build {
    name: "Build"
    "runs-on": "ubuntu-latest"
    needs: ["test"]
    steps: [
      actions.checkout,
      actions.setup_node_fixed,
      actions.install_deps,
      { name: "Build", run: "npm run build" },
      {
        name: "Upload build artifact",
        uses: "actions/upload-artifact@v4",
        with: { name: "dist", path: "dist/", "retention-days": 7 },
      },
    ]
  }

  docker {
    name: "Docker Image"
    "runs-on": "ubuntu-latest"
    needs: ["build"]
    "if": "github.event_name == 'push' && github.ref == 'refs/heads/main'"
    permissions: { contents: "read", packages: "write" }
    steps: [
      actions.checkout,
      actions.setup_docker_buildx,
      actions.docker_login,
      {
        name: "Build and push",
        uses: "docker/build-push-action@v5",
        with: {
          context: ".",
          push: true,
          tags: join([
            'ghcr.io/\${{ github.repository }}:latest',
            'ghcr.io/\${{ github.repository }}:\${{ github.sha }}',
          ], "\\n"),
          cache_from: 'type=gha',
          cache_to: 'type=gha,mode=max',
        },
      },
    ]
  }

  when deploy_enabled {
    deploy {
      name: "Deploy to \${deploy_env}"
      "runs-on": "ubuntu-latest"
      needs: ["docker"]
      "if": "github.event_name == 'push' && github.ref == 'refs/heads/main'"
      environment {
        name: deploy_env
        url: deploy_url
      }
      steps: [
        actions.checkout,
        {
          name: "Deploy to \${deploy_env}",
          uses: "cloudflare/wrangler-action@v3",
          with: {
            environment: deploy_env,
            apiToken: '\${{ secrets.DEPLOY_TOKEN }}',
          },
        },
      ]
    }
  }
}`,
'./actions.hone': `# Reusable action step patterns
#
# Define once, spread everywhere. No more copy-pasting checkout + setup steps.

let checkout = {
  name: "Checkout",
  uses: "actions/checkout@v4",
}

let setup_node = {
  name: "Set up Node.js",
  uses: "actions/setup-node@v4",
  with: {
    "node-version": '\${{ matrix.node-version }}',
    cache: "npm",
  },
}

let setup_node_fixed = {
  name: "Set up Node.js",
  uses: "actions/setup-node@v4",
  with: {
    "node-version": "20",
    cache: "npm",
  },
}

let install_deps = {
  name: "Install dependencies",
  run: "npm ci",
}

let docker_login = {
  name: "Log in to GHCR",
  uses: "docker/login-action@v3",
  with: {
    registry: "ghcr.io",
    username: '\${{ github.actor }}',
    password: '\${{ secrets.GITHUB_TOKEN }}',
  },
}

let setup_docker_buildx = {
  name: "Set up Docker Buildx",
  uses: "docker/setup-buildx-action@v3",
}`,
        },
      },
      ansible: {
        entry: './main.hone',
        files: {
'./main.hone': `# Ansible Playbook \u2014 Flask App Deployment
#
# Demonstrates Hone generating Ansible YAML, including reserved-word keys
# ("when", "import", "type"), Jinja2 passthrough ({{ }}), yes/no strings,
# register, loops, handlers, and variant-controlled environments.

import "./vars.hone" as vars

# \u2500\u2500 Environment variants \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500

variant env {
  default staging {
    let gunicorn_workers = 2
    let nginx_server_name = "staging.yeetops.dev"
    let ssl_enabled = false
    let app_branch = "develop"
  }
  production {
    let gunicorn_workers = 8
    let nginx_server_name = "app.yeetops.dev"
    let ssl_enabled = true
    let app_branch = "main"
  }
}

# \u2500\u2500 Play \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500

name: "Deploy \${vars.app_name}"
hosts: "webservers"
become: true
gather_facts: true

vars {
  app_name: vars.app_name
  app_dir: vars.app_dir
  app_port: vars.app_port
  gunicorn_workers: gunicorn_workers
  nginx_server_name: nginx_server_name
}

# \u2500\u2500 Tasks \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500

tasks: [

  # --- System setup ---

  {
    name: "Install system packages"
    ...vars.apt_install
    tags: ["setup", "packages"]
  },

  {
    name: "Create app user"
    user: {
      name: vars.app_user
      shell: "/bin/bash"
      system: "yes"
      home: vars.app_dir
      create_home: "yes"
    }
  },

  # --- SSH access ---

  for user in vars.users {
    name: "Add SSH key for \${user.name}"
    authorized_key: {
      user: user.name
      key: user.key
      state: "present"
    }
    "when": "ansible_os_family == 'Debian'"
    tags: ["users"]
  },

  # --- Firewall ---

  for port in vars.firewall_ports {
    name: "Allow \${port} through firewall"
    "community.general.ufw": {
      rule: "allow"
      port: replace(port, "/tcp", "")
      proto: "tcp"
    }
    tags: ["firewall"]
  },

  {
    name: "Enable firewall"
    "community.general.ufw": { state: "enabled", "policy": "deny" }
    tags: ["firewall"]
  },

  # --- Application ---

  {
    name: "Clone application repo"
    git: {
      repo: vars.app_repo
      dest: vars.app_dir
      version: app_branch
      force: "yes"
    }
    become_user: vars.app_user
    notify: ["restart app"]
    register: "git_result"
  },

  {
    name: "Create virtualenv and install deps"
    pip: {
      requirements: "\${vars.app_dir}/requirements.txt"
      virtualenv: vars.venv_dir
      virtualenv_command: "python3 -m venv"
    }
    become_user: vars.app_user
    "when": "git_result.changed"
  },

  {
    name: "Create log directory"
    file: {
      path: vars.log_dir
      state: "directory"
      owner: vars.app_user
      group: vars.app_user
      mode: "0755"
    }
  },

  # --- Config files (Jinja2 passthrough) ---

  {
    name: "Deploy app config"
    template: {
      src: "templates/config.ini.j2"
      dest: "\${vars.config_dir}/config.ini"
      owner: vars.app_user
      mode: "0600"
    }
    notify: ["restart app"]
    tags: ["config"]
  },

  {
    name: "Deploy supervisor config"
    template: {
      src: "templates/supervisor.conf.j2"
      dest: "/etc/supervisor/conf.d/\${vars.app_name}.conf"
    }
    notify: ["restart app"]
    vars: {
      workers: "{{ gunicorn_workers }}"
      bind: "127.0.0.1:{{ app_port }}"
    }
  },

  {
    name: "Deploy nginx site config"
    template: {
      src: "templates/nginx.conf.j2"
      dest: "/etc/nginx/sites-available/\${vars.app_name}"
      owner: "root"
      mode: "0644"
    }
    notify: ["reload nginx"]
    vars: {
      server_name: "{{ nginx_server_name }}"
      upstream_port: "{{ app_port }}"
    }
  },

  {
    name: "Enable nginx site"
    file: {
      src: "/etc/nginx/sites-available/\${vars.app_name}"
      dest: "/etc/nginx/sites-enabled/\${vars.app_name}"
      state: "link"
    }
    notify: ["reload nginx"]
  },

  # --- SSL (production only) ---

  {
    name: "Install certbot"
    apt: { name: ["certbot", "python3-certbot-nginx"], state: "present" }
    "when": to_str(ssl_enabled)
    tags: ["ssl"]
  },

  {
    name: "Obtain SSL certificate"
    command: "certbot --nginx -d {{ nginx_server_name }} --non-interactive --agree-tos -m ops@yeetops.dev"
    args: { creates: "/etc/letsencrypt/live/{{ nginx_server_name }}/fullchain.pem" }
    "when": to_str(ssl_enabled)
    tags: ["ssl"]
  },

  # --- Services ---

  {
    name: "Start supervisor"
    ...vars.enable_service
    systemd {
      name: "supervisor"
    }
  },

  {
    name: "Start nginx"
    ...vars.enable_service
    systemd {
      name: "nginx"
    }
  },

  # --- Smoke test ---

  {
    name: "Verify app is responding"
    uri: {
      url: "http://127.0.0.1:\${to_str(vars.app_port)}/health"
      status_code: [200]
      timeout: 30
    }
    retries: 5
    delay: 3
    register: "health_check"
    "when": "git_result.changed"
    tags: ["verify"]
  },

  {
    name: "Show deploy result"
    debug: {
      msg: "Deployed \${vars.app_name} ({{ ansible_hostname }}), healthy: {{ health_check.status | default('skipped') }}"
    }
    tags: ["verify"]
  },
]

# \u2500\u2500 Handlers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500

handlers: [
  {
    name: "restart app"
    supervisorctl: {
      name: vars.app_name
      state: "restarted"
    }
  },
  {
    name: "reload nginx"
    systemd: {
      name: "nginx"
      state: "reloaded"
    }
  },
]`,
'./vars.hone': `# Shared variables and reusable task patterns for the playbook

# \u2500\u2500 App settings \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500

let app_name = "helloflask"
let app_user = "deploy"
let app_port = 5000
let app_repo = "https://github.com/yeetops/helloflask.git"
let app_dir = "/opt/\${app_name}"
let venv_dir = "\${app_dir}/venv"
let config_dir = "/etc/\${app_name}"
let log_dir = "/var/log/\${app_name}"

let system_packages = [
  "nginx", "python3", "python3-venv", "python3-pip",
  "git", "supervisor", "ufw",
]

let firewall_ports = ["22/tcp", "80/tcp", "443/tcp"]

# \u2500\u2500 Users \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500

let users = [
  { name: "alice", groups: "admin,docker", key: "ssh-ed25519 AAAA... alice@ops" },
  { name: "bob", groups: "docker", key: "ssh-ed25519 AAAA... bob@ops" },
]

# \u2500\u2500 Reusable task patterns \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500

let apt_install = {
  apt: {
    name: system_packages,
    state: "present",
    update_cache: "yes",
    cache_valid_time: 3600,
  }
}

let enable_service = {
  systemd: {
    enabled: "yes",
    state: "started",
    daemon_reload: "yes",
  }
}`,
        },
      },
    };

    // Parse "key=value key2=value2" into a JSON object string
    function parseKeyValues(str) {
      if (!str.trim()) return '';
      const obj = {};
      const pairs = str.trim().split(/\s+/);
      for (const pair of pairs) {
        const eq = pair.indexOf('=');
        if (eq > 0) {
          obj[pair.substring(0, eq)] = pair.substring(eq + 1);
        }
      }
      return Object.keys(obj).length > 0 ? JSON.stringify(obj) : '';
    }

    // --- Helper: get editor value ---
    function getEditorValue() {
      return editor ? editor.getValue() : '';
    }

    function setEditorValue(value) {
      if (editor) editor.setValue(value);
    }

    // Show options bar if source contains variant or expect
    function updateOptionsBarVisibility() {
      let allSource;
      if (isMultiFile) {
        allSource = Object.values(projectFiles).join('\n');
      } else {
        allSource = getEditorValue();
      }
      const hasVariant = /\bvariant\b/.test(allSource);
      const hasExpect = /\bexpect\b/.test(allSource);
      optionsBar.style.display = (hasVariant || hasExpect) ? 'flex' : 'none';
    }

    // --- Tab management ---
    let entryPointFile = null;
    // Monaco models per file (for multi-file)
    let fileModels = {}; // { filename: monaco.editor.ITextModel }
    // Cursor state per file
    let fileCursorStates = {}; // { filename: editor.saveViewState() }

    function setProjectFiles(files, entry) {
      disposeFileModels();
      projectFiles = { ...files };
      activeFile = entry;
      entryPointFile = entry;
      isMultiFile = Object.keys(files).length > 1;
      renderFileTabs();
      if (editor && monaco) {
        // Create models for each file
        for (const [name, source] of Object.entries(projectFiles)) {
          const uri = monaco.Uri.parse('inmemory://model/' + name);
          fileModels[name] = monaco.editor.createModel(source, 'hone', uri);
        }
        if (fileModels[activeFile]) {
          editor.setModel(fileModels[activeFile]);
        }
      } else {
        // Fallback before Monaco is loaded
      }
    }

    function disposeFileModels() {
      for (const model of Object.values(fileModels)) {
        model.dispose();
      }
      fileModels = {};
      fileCursorStates = {};
    }

    function getEntryPoint() {
      if (!isMultiFile) return null;
      return entryPointFile || Object.keys(projectFiles)[0];
    }

    function setSingleFile(source) {
      disposeFileModels();
      projectFiles = {};
      activeFile = null;
      isMultiFile = false;
      renderFileTabs();
      if (editor && monaco) {
        // Use a single default model
        const uri = monaco.Uri.parse('inmemory://model/main.hone');
        const model = monaco.editor.createModel(source, 'hone', uri);
        fileModels['__single__'] = model;
        editor.setModel(model);
      }
    }

    function renderFileTabs() {
      if (!isMultiFile) {
        fileTabsEl.style.display = 'none';
        fileTabsEl.innerHTML = '';
        return;
      }
      fileTabsEl.style.display = 'flex';
      fileTabsEl.innerHTML = '';
      const filenames = Object.keys(projectFiles);
      for (const name of filenames) {
        const tab = document.createElement('div');
        tab.className = 'file-tab' + (name === activeFile ? ' active' : '');
        tab.textContent = name.replace(/^\.\//, '');
        tab.onclick = () => switchToFile(name);
        fileTabsEl.appendChild(tab);
      }
    }

    function switchToFile(name) {
      if (!editor) return;
      if (activeFile && isMultiFile) {
        // Save current content and cursor state
        projectFiles[activeFile] = getEditorValue();
        fileCursorStates[activeFile] = editor.saveViewState();
      }
      activeFile = name;
      if (fileModels[name]) {
        editor.setModel(fileModels[name]);
        if (fileCursorStates[name]) {
          editor.restoreViewState(fileCursorStates[name]);
        }
      }
      renderFileTabs();
    }

    function saveActiveFile() {
      if (isMultiFile && activeFile) {
        projectFiles[activeFile] = getEditorValue();
        // Sync model content
        if (fileModels[activeFile]) {
          const model = fileModels[activeFile];
          const editorVal = getEditorValue();
          if (model.getValue() !== editorVal) {
            model.setValue(editorVal);
          }
        }
      }
    }

    function renderOutputTabs() {
      if (outputDocs.length <= 1) {
        outputTabsEl.style.display = 'none';
        outputTabsEl.innerHTML = '';
        return;
      }
      outputTabsEl.style.display = 'flex';
      outputTabsEl.innerHTML = '';
      for (let i = 0; i < outputDocs.length; i++) {
        const tab = document.createElement('div');
        tab.className = 'file-tab' + (i === activeOutputDoc ? ' active' : '');
        tab.textContent = outputDocs[i].name || '(main)';
        tab.onclick = () => switchOutputDoc(i);
        outputTabsEl.appendChild(tab);
      }
    }

    function switchOutputDoc(idx) {
      activeOutputDoc = idx;
      outputEl.textContent = outputDocs[idx]?.content || '';
      renderOutputTabs();
    }

    // --- Monaco setup ---
    function setupMonaco() {
      return new Promise((resolve) => {
        window.require.config({
          paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs' }
        });
        window.require(['vs/editor/editor.main'], (m) => {
          monaco = m;
          registerHoneLanguage(monaco);
          defineCatppuccinTheme(monaco);
          resolve(monaco);
        });
      });
    }

    function registerHoneLanguage(monaco) {
      monaco.languages.register({ id: 'hone' });

      monaco.languages.setMonarchTokensProvider('hone', {
        keywords: [
          'let', 'when', 'else', 'for', 'in', 'import', 'from', 'as',
          'schema', 'variant', 'assert', 'expect', 'secret', 'policy',
          'use', 'type', 'deny', 'warn', 'default', 'extends', 'fn',
        ],
        builtins: [
          'len', 'keys', 'values', 'contains', 'concat', 'merge', 'flatten',
          'upper', 'lower', 'trim', 'split', 'join', 'replace', 'range',
          'base64_encode', 'base64_decode', 'to_json', 'from_json',
          'to_str', 'to_int', 'to_float', 'to_bool', 'env', 'file',
          'sort', 'reverse', 'unique', 'slice', 'min', 'max', 'abs',
          'clamp', 'starts_with', 'ends_with', 'substring', 'type_of',
          'entries', 'from_entries', 'sha256', 'default',
        ],
        constants: ['true', 'false', 'null'],
        operators: [
          '+:', '!:', '...', '??', '==', '!=', '<=', '>=', '&&', '||',
          '+', '-', '*', '/', '%', '<', '>', '!', '?', ':',
        ],
        symbols: /[=><!~?:&|+\-*\/\^%]+/,
        escapes: /\\(?:[abfnrtv\\"']|\$\{|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4})/,

        tokenizer: {
          root: [
            // Document separator
            [/^---\w*/, 'keyword.control'],
            // Comments
            [/#.*$/, 'comment'],
            // Triple-quoted strings
            [/"""/, 'string', '@tripleString'],
            // Double-quoted strings with interpolation
            [/"/, 'string', '@string'],
            // Single-quoted literal strings
            [/'[^']*'/, 'string'],
            // Numbers
            [/\b\d+\.\d+([eE][+-]?\d+)?\b/, 'number.float'],
            [/\b\d+([eE][+-]?\d+)?\b/, 'number'],
            // Identifiers and keywords
            [/[a-zA-Z_]\w*/, {
              cases: {
                '@keywords': 'keyword',
                '@builtins': 'support.function',
                '@constants': 'constant.language',
                '@default': 'identifier',
              },
            }],
            // Operators
            [/\.\.\./, 'operator'],
            [/[+!]:/, 'operator'],
            [/@symbols/, 'operator'],
            // Brackets
            [/[{}()\[\]]/, '@brackets'],
            // Decorators (@unchecked)
            [/@\w+/, 'annotation'],
          ],
          string: [
            [/\$\{/, { token: 'delimiter.bracket', next: '@interpolation' }],
            [/[^\\"$]+/, 'string'],
            [/@escapes/, 'string.escape'],
            [/\\./, 'string.escape.invalid'],
            [/"/, 'string', '@pop'],
          ],
          interpolation: [
            [/\}/, { token: 'delimiter.bracket', next: '@pop' }],
            { include: 'root' },
          ],
          tripleString: [
            [/"""/, 'string', '@pop'],
            [/\$\{/, { token: 'delimiter.bracket', next: '@interpolation' }],
            [/./, 'string'],
          ],
        },
      });
    }

    function defineCatppuccinTheme(monaco) {
      monaco.editor.defineTheme('catppuccin-mocha', {
        base: 'vs-dark',
        inherit: true,
        rules: [
          { token: 'keyword', foreground: 'cba6f7' },        // mauve
          { token: 'keyword.control', foreground: 'cba6f7' },
          { token: 'support.function', foreground: '89b4fa' }, // blue
          { token: 'constant.language', foreground: 'fab387' }, // peach
          { token: 'string', foreground: 'a6e3a1' },          // green
          { token: 'string.escape', foreground: 'f5c2e7' },   // pink
          { token: 'number', foreground: 'fab387' },           // peach
          { token: 'number.float', foreground: 'fab387' },
          { token: 'comment', foreground: '6c7086' },          // overlay1
          { token: 'operator', foreground: '89dceb' },         // sky
          { token: 'delimiter.bracket', foreground: 'f5c2e7' },
          { token: 'annotation', foreground: 'f9e2af' },      // yellow
          { token: 'identifier', foreground: 'cdd6f4' },      // text
          { token: '', foreground: 'cdd6f4' },
        ],
        colors: {
          'editor.background': '#1e1e2e',
          'editor.foreground': '#cdd6f4',
          'editor.lineHighlightBackground': '#313244',
          'editor.selectionBackground': '#45475a',
          'editorCursor.foreground': '#f5e0dc',
          'editorLineNumber.foreground': '#6c7086',
          'editorLineNumber.activeForeground': '#cdd6f4',
          'editorWidget.background': '#181825',
          'editorWidget.border': '#45475a',
          'editorSuggestWidget.background': '#181825',
          'editorSuggestWidget.border': '#45475a',
          'editorSuggestWidget.selectedBackground': '#313244',
          'editorHoverWidget.background': '#181825',
          'editorHoverWidget.border': '#45475a',
          'input.background': '#313244',
          'input.border': '#45475a',
          'input.foreground': '#cdd6f4',
          'list.hoverBackground': '#313244',
          'scrollbarSlider.background': '#45475a80',
          'scrollbarSlider.hoverBackground': '#585b70',
        },
      });
    }

    function wireProviders(monaco) {
      // --- Diagnostics (on content change, debounced) ---
      function updateDiagnostics() {
        if (!editor) return;
        const model = editor.getModel();
        if (!model) return;
        const source = model.getValue();
        try {
          const raw = get_diagnostics(source);
          const diags = JSON.parse(raw);
          const markers = diags.map(d => ({
            startLineNumber: d.startLine + 1,
            startColumn: d.startCol + 1,
            endLineNumber: d.endLine + 1,
            endColumn: d.endCol + 1,
            message: d.message,
            severity: d.severity,
          }));
          monaco.editor.setModelMarkers(model, 'hone', markers);
        } catch {
          monaco.editor.setModelMarkers(model, 'hone', []);
        }
      }

      // --- Completions ---
      monaco.languages.registerCompletionItemProvider('hone', {
        triggerCharacters: ['.', ':'],
        provideCompletionItems(model, position) {
          const source = model.getValue();
          const line = position.lineNumber - 1;
          const col = position.column - 1;
          try {
            const raw = get_completions(source, line, col);
            const items = JSON.parse(raw);
            const word = model.getWordUntilPosition(position);
            const range = {
              startLineNumber: position.lineNumber,
              startColumn: word.startColumn,
              endLineNumber: position.lineNumber,
              endColumn: word.endColumn,
            };
            return {
              suggestions: items.map(item => ({
                label: item.label,
                kind: item.kind,
                detail: item.detail,
                insertText: item.insertText,
                insertTextRules: item.insertTextFormat === 2
                  ? monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet
                  : undefined,
                sortText: item.sortText,
                range,
              })),
            };
          } catch {
            return { suggestions: [] };
          }
        },
      });

      // --- Hover ---
      monaco.languages.registerHoverProvider('hone', {
        provideHover(model, position) {
          const source = model.getValue();
          const line = position.lineNumber - 1;
          const col = position.column - 1;
          try {
            const raw = get_hover(source, line, col);
            if (!raw) return null;
            const data = JSON.parse(raw);
            if (!data.contents) return null;
            return {
              contents: [{ value: data.contents }],
            };
          } catch {
            return null;
          }
        },
      });

      // Wire diagnostics to model change events
      editor.onDidChangeModelContent(() => {
        saveActiveFile();
        updateOptionsBarVisibility();
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(doCompile, 300);
        clearTimeout(diagnosticsTimer);
        diagnosticsTimer = setTimeout(updateDiagnostics, 300);
      });

      // Also update diagnostics when model changes (tab switch)
      editor.onDidChangeModel(() => {
        clearTimeout(diagnosticsTimer);
        diagnosticsTimer = setTimeout(updateDiagnostics, 100);
      });

      // Initial diagnostics
      updateDiagnostics();
    }

    async function start() {
      wasm = await init();
      const m = await setupMonaco();

      // Create editor
      editor = m.editor.create(document.getElementById('editor-container'), {
        language: 'hone',
        theme: 'catppuccin-mocha',
        automaticLayout: true,
        minimap: { enabled: false },
        fontSize: 14,
        lineHeight: 21,
        fontFamily: '"JetBrains Mono", "Fira Code", "Cascadia Code", "Consolas", monospace',
        tabSize: 2,
        insertSpaces: true,
        scrollBeyondLastLine: false,
        padding: { top: 8, bottom: 8 },
        renderLineHighlight: 'line',
        overviewRulerLanes: 0,
        hideCursorInOverviewRuler: true,
        scrollbar: {
          verticalScrollbarSize: 8,
          horizontalScrollbarSize: 8,
        },
      });

      // Load from URL hash
      const hash = window.location.hash.slice(1);
      if (hash) {
        try {
          const decoded = atob(hash);
          const data = JSON.parse(decoded);
          if (data.files && data.entry) {
            setProjectFiles(data.files, data.entry);
          } else {
            setSingleFile(data.s || '');
          }
          if (data.f) {
            currentFormat = data.f;
            formatSelect.value = currentFormat;
            updateTabs();
          }
          if (data.v) variantInput.value = data.v;
          if (data.a) argsInput.value = data.a;
        } catch {
          setSingleFile(EXAMPLES.basics);
        }
      } else {
        setSingleFile(EXAMPLES.basics);
      }

      wireProviders(monaco);

      updateOptionsBarVisibility();
      updateTabs();
      doCompile();

      formatSelect.addEventListener('change', () => {
        currentFormat = formatSelect.value;
        updateTabs();
        doCompile();
      });

      examplesSelect.addEventListener('change', () => {
        const name = examplesSelect.value;
        if (!name) return;

        variantInput.value = '';
        argsInput.value = '';

        if (MULTI_EXAMPLES[name]) {
          const ex = MULTI_EXAMPLES[name];
          setProjectFiles(ex.files, ex.entry);
        } else if (EXAMPLES[name]) {
          setSingleFile(EXAMPLES[name]);
        }

        if (name === 'args') {
          argsInput.value = 'env=prod';
        }

        updateOptionsBarVisibility();
        doCompile();
        examplesSelect.value = '';
      });

      prettyPrint.addEventListener('change', doCompile);

      variantInput.addEventListener('input', () => {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(doCompile, 300);
      });
      argsInput.addEventListener('input', () => {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(doCompile, 300);
      });
    }

    function doCompile() {
      saveActiveFile();

      const variantJson = parseKeyValues(variantInput.value);
      const argsJson = parseKeyValues(argsInput.value);
      const fmt = (currentFormat === 'json' && prettyPrint.checked) ? 'json-pretty' : currentFormat;

      let result;
      if (isMultiFile) {
        const filesJson = JSON.stringify(projectFiles);
        const entryPoint = getEntryPoint();
        if (!entryPoint) {
          outputEl.textContent = 'No entry point defined';
          outputEl.className = 'error';
          statusEl.textContent = 'Error';
          statusEl.className = 'status err';
          return;
        }
        result = compile_project(filesJson, entryPoint, fmt, variantJson, argsJson);
      } else {
        const source = getEditorValue();
        if (!source.trim()) {
          outputEl.textContent = '';
          statusEl.textContent = '';
          statusEl.className = 'status';
          return;
        }
        result = compile(source, fmt, variantJson, argsJson);
      }

      if (result.success) {
        if (result.multi_doc) {
          try {
            outputDocs = JSON.parse(result.output);
            activeOutputDoc = 0;
            renderOutputTabs();
            outputEl.textContent = outputDocs[0]?.content || '';
          } catch {
            outputDocs = [];
            renderOutputTabs();
            outputEl.textContent = result.output;
          }
        } else {
          outputDocs = [];
          renderOutputTabs();
          outputEl.textContent = result.output;
        }
        outputEl.className = '';
        statusEl.textContent = 'OK';
        statusEl.className = 'status ok';
      } else {
        outputDocs = [];
        renderOutputTabs();
        outputEl.textContent = result.error;
        outputEl.className = 'error';
        statusEl.textContent = 'Error';
        statusEl.className = 'status err';
      }
    }

    function updateTabs() {
      document.querySelectorAll('.tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.format === currentFormat);
      });
      prettyToggle.style.display = currentFormat === 'json' ? '' : 'none';
    }

    window.setFormat = function(fmt) {
      currentFormat = fmt;
      formatSelect.value = fmt;
      updateTabs();
      doCompile();
    };

    window.formatCode = function() {
      const result = format_source(getEditorValue());
      if (result.success) {
        setEditorValue(result.output);
        saveActiveFile();
        doCompile();
      }
    };

    window.share = function() {
      let data;
      if (isMultiFile) {
        saveActiveFile();
        data = {
          files: projectFiles,
          entry: entryPointFile,
          f: currentFormat,
        };
      } else {
        data = {
          s: getEditorValue(),
          f: currentFormat,
        };
      }
      if (variantInput.value.trim()) data.v = variantInput.value;
      if (argsInput.value.trim()) data.a = argsInput.value;
      const encoded = btoa(JSON.stringify(data));
      window.location.hash = encoded;
      navigator.clipboard.writeText(window.location.href).then(() => {
        const btn = document.querySelector('.share');
        btn.textContent = 'Copied!';
        setTimeout(() => { btn.textContent = 'Share'; }, 2000);
      });
    };

    start();
  </script>
</body>
</html>
